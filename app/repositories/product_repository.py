from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy import or_
from app.models import Product, Base
from app.models.schemas import ProductCreate, ProductUpdate, ProductFilters
from uuid import UUID


class ProductRepository:
    """Repository layer for product data access operations"""
    
    def __init__(self, db: Session):
        self.db = db
        self.model = Product
    
    def get_all(self) -> List[Product]:
        """Retrieve all products from the database"""
        try:
            return self.db.query(self.model).all()
        except SQLAlchemyError as e:
            raise Exception(f"Error retrieving products: {str(e)}")
    
    def get_by_id(self, product_id: UUID) -> Optional[Product]:
        """Retrieve a product by its UUID"""
        try:
            return self.db.query(self.model).filter(
                self.model.id == product_id
            ).first()
        except SQLAlchemyError as e:
            raise Exception(f"Error retrieving product: {str(e)}")
    
    def create(self, product_data: ProductCreate) -> Product:
        """Create a new product in the database"""
        try:
            db_product = self.model(**product_data.model_dump())
            # UUID is auto-generated by database default
            self.db.add(db_product)
            self.db.commit()
            self.db.refresh(db_product)
            return db_product
        except SQLAlchemyError as e:
            self.db.rollback()
            raise Exception(f"Error creating product: {str(e)}")
    
    def update(self, product_id: UUID, product_data: ProductUpdate) -> Optional[Product]:
        """Update an existing product in the database"""
        try:
            db_product = self.get_by_id(product_id)
            if not db_product:
                return None
            
            # Update only provided fields
            update_data = product_data.model_dump(exclude_unset=True)
            for field, value in update_data.items():
                setattr(db_product, field, value)
            
            self.db.commit()
            self.db.refresh(db_product)
            return db_product
        except SQLAlchemyError as e:
            self.db.rollback()
            raise Exception(f"Error updating product: {str(e)}")
    
    def delete(self, product_id: UUID) -> bool:
        """Delete a product from the database"""
        try:
            db_product = self.get_by_id(product_id)
            if not db_product:
                return False
            
            self.db.delete(db_product)
            self.db.commit()
            return True
        except SQLAlchemyError as e:
            self.db.rollback()
            raise Exception(f"Error deleting product: {str(e)}")
    
    def get_with_filters(self, filters: ProductFilters) -> List[Product]:
        """Retrieve products with AI-generated filters"""
        try:
            q = self.db.query(self.model)
            all_conditions = []

            # Name search - handle array of search terms with OR logic
            if filters.name and filters.name.contains:
                name_conditions = []
                for term in filters.name.contains:
                    value = f"%{term}%"
                    name_conditions.append(self.model.name.ilike(value))
                if name_conditions:
                    all_conditions.extend(name_conditions)

            # Description search - handle array of search terms with OR logic
            if filters.description and filters.description.contains:
                desc_conditions = []
                for term in filters.description.contains:
                    value = f"%{term}%"
                    desc_conditions.append(self.model.description.ilike(value))
                if desc_conditions:
                    all_conditions.extend(desc_conditions)

            # Quantity filters
            if filters.quantity:
                if filters.quantity.lt is not None and filters.quantity.lt > 0:
                    all_conditions.append(self.model.quantity < filters.quantity.lt)
                if filters.quantity.gt is not None and filters.quantity.gt > 0:
                    all_conditions.append(self.model.quantity > filters.quantity.gt)

            # Price filters
            if filters.price:
                if filters.price.lt is not None and filters.price.lt > 0:
                    all_conditions.append(self.model.price < filters.price.lt)
                if filters.price.gt is not None and filters.price.gt > 0:
                    all_conditions.append(self.model.price > filters.price.gt)

            # Apply all conditions with OR logic
            if all_conditions:
                q = q.filter(or_(*all_conditions))

            # print("\n\n", q.statement, "\n\n", filters, "\n\n")

            return q.all()
        except SQLAlchemyError as e:
            raise Exception(f"Error retrieving filtered products: {str(e)}")
    
    def count(self) -> int:
        """Count the total number of products"""
        try:
            return self.db.query(self.model).count()
        except SQLAlchemyError as e:
            raise Exception(f"Error counting products: {str(e)}")
