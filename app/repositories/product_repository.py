from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
import database_models
from app.models.schemas import ProductCreate, ProductUpdate
from uuid import UUID


class ProductRepository:
    """Repository layer for product data access operations"""
    
    def __init__(self, db: Session):
        self.db = db
        self.model = database_models.Product
    
    def get_all(self) -> List[database_models.Product]:
        """Retrieve all products from the database"""
        try:
            return self.db.query(self.model).all()
        except SQLAlchemyError as e:
            raise Exception(f"Error retrieving products: {str(e)}")
    
    def get_by_id(self, product_id: UUID) -> Optional[database_models.Product]:
        """Retrieve a product by its UUID"""
        try:
            return self.db.query(self.model).filter(
                self.model.id == product_id
            ).first()
        except SQLAlchemyError as e:
            raise Exception(f"Error retrieving product: {str(e)}")
    
    def create(self, product_data: ProductCreate) -> database_models.Product:
        """Create a new product in the database"""
        try:
            db_product = self.model(**product_data.model_dump())
            # UUID is auto-generated by database default
            self.db.add(db_product)
            self.db.commit()
            self.db.refresh(db_product)
            return db_product
        except SQLAlchemyError as e:
            self.db.rollback()
            raise Exception(f"Error creating product: {str(e)}")
    
    def update(self, product_id: UUID, product_data: ProductUpdate) -> Optional[database_models.Product]:
        """Update an existing product in the database"""
        try:
            db_product = self.get_by_id(product_id)
            if not db_product:
                return None
            
            # Update only provided fields
            update_data = product_data.model_dump(exclude_unset=True)
            for field, value in update_data.items():
                setattr(db_product, field, value)
            
            self.db.commit()
            self.db.refresh(db_product)
            return db_product
        except SQLAlchemyError as e:
            self.db.rollback()
            raise Exception(f"Error updating product: {str(e)}")
    
    def delete(self, product_id: UUID) -> bool:
        """Delete a product from the database"""
        try:
            db_product = self.get_by_id(product_id)
            if not db_product:
                return False
            
            self.db.delete(db_product)
            self.db.commit()
            return True
        except SQLAlchemyError as e:
            self.db.rollback()
            raise Exception(f"Error deleting product: {str(e)}")
    
    def count(self) -> int:
        """Count the total number of products"""
        try:
            return self.db.query(self.model).count()
        except SQLAlchemyError as e:
            raise Exception(f"Error counting products: {str(e)}")
